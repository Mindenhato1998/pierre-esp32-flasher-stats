<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pierre ESP32 - Live Device Status & Analytics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid #333;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            font-size: 1.1rem;
            color: #888;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-online {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
            animation: pulse 2s infinite;
        }

        .status-offline {
            background: #ff4444;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        .devices-section {
            background: #111;
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid #333;
        }

        .devices-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #fff;
        }

        .device-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .device-item {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 1.5rem;
            border: 1px solid #2a2a2a;
            transition: all 0.3s ease;
        }

        .device-item:hover {
            border-color: #444;
            transform: translateY(-2px);
        }

        .device-name {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
        }

        .device-info {
            font-size: 0.9rem;
            color: #888;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .last-seen {
            font-size: 0.8rem;
            color: #666;
        }

        .no-devices {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 3rem;
        }

        .connection-status {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1rem;
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .connection-status.connected {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        .connection-status.disconnected {
            border-color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
        }

        .refresh-info {
            text-align: center;
            margin-top: 2rem;
            font-size: 0.9rem;
            color: #666;
        }

        .chart-section {
            background: #111;
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid #333;
            margin-top: 2rem;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .chart-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
            margin: 0;
        }

        .reset-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reset-btn:hover {
            background: #444;
            border-color: #666;
            transform: translateY(-1px);
        }

        .reset-btn:active {
            transform: translateY(0);
            background: #555;
        }

        .chart-container {
            position: relative;
            height: 200px;
            background: #1a1a1a;
            border-radius: 8px;
            padding: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Pierre ESP32 Flasher</h1>
            <p>Live Device Status Monitor</p>
        </div>

        <div class="connection-status" id="connectionStatus">
            <span class="status-indicator status-offline"></span>
            <span id="connectionText">Connecting to HiveMQ...</span>
        </div>

        <div class="devices-section">
            <h2 class="devices-title">Connected Devices</h2>
            <div class="device-list" id="deviceList">
                <div class="no-devices" id="noDevices">
                    <p>No devices connected</p>
                </div>
            </div>
        </div>

        <div class="refresh-info">
            <p>Real-time monitoring via HiveMQ Cloud</p>
        </div>

        <div class="chart-section">
            <div class="chart-header">
                <h2 class="chart-title">Device Count (Last 24 Hours)</h2>
                <button id="resetChart" class="reset-btn">Reset Chart</button>
            </div>
            <div class="chart-container">
                <canvas id="deviceChart" width="800" height="200"></canvas>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // MQTT connection settings
        const MQTT_HOST = 'wss://0c1bf62a21e94682adf340b8a2d3fe04.s1.eu.hivemq.cloud:8884/mqtt';
        const USERNAME = 'pierreflasher';
        const PASSWORD = 'Pierre2k23';

        // Store connected devices
        const connectedDevices = new Map();
        let client = null;

        // Chart data - store device count over time (last 24 hours)
        const chartData = [];
        let deviceChart = null;

        // DOM elements
        const connectionStatus = document.getElementById('connectionStatus');
        const connectionText = document.getElementById('connectionText');
        const deviceList = document.getElementById('deviceList');
        const noDevices = document.getElementById('noDevices');

        function updateConnectionStatus(connected) {
            const indicator = connectionStatus.querySelector('.status-indicator');

            if (connected) {
                connectionStatus.className = 'connection-status connected';
                indicator.className = 'status-indicator status-online';
                connectionText.textContent = 'Connected to HiveMQ Cloud';
            } else {
                connectionStatus.className = 'connection-status disconnected';
                indicator.className = 'status-indicator status-offline';
                connectionText.textContent = 'Disconnected from HiveMQ';
            }
        }

        function updateDeviceList() {
            // Clear current list
            deviceList.innerHTML = '';

            if (connectedDevices.size === 0) {
                deviceList.appendChild(noDevices);
                return;
            }

            // Group devices by unique identifier (name or ID)
            const uniqueDevices = new Map();

            connectedDevices.forEach((deviceData, deviceId) => {
                const uniqueKey = deviceData.name && deviceData.name !== deviceId ? deviceData.name : deviceId;

                // If we already have this device, keep the most recent data
                if (uniqueDevices.has(uniqueKey)) {
                    const existing = uniqueDevices.get(uniqueKey);
                    if (deviceData.lastSeen > existing.lastSeen) {
                        uniqueDevices.set(uniqueKey, {
                            ...deviceData,
                            primaryId: deviceId,
                            allIds: [...existing.allIds, deviceId]
                        });
                    } else {
                        // Add this deviceId to the existing entry's allIds
                        existing.allIds.push(deviceId);
                    }
                } else {
                    uniqueDevices.set(uniqueKey, {
                        ...deviceData,
                        primaryId: deviceId,
                        allIds: [deviceId]
                    });
                }
            });

            // Create device items for unique devices only
            uniqueDevices.forEach((deviceData, uniqueKey) => {
                const deviceItem = document.createElement('div');
                deviceItem.className = 'device-item';

                const timeSinceLastSeen = Date.now() - deviceData.lastSeen;
                const isOnline = timeSinceLastSeen < 30000; // 30 seconds threshold

                // Show primary ID, or if multiple IDs, show count
                const idDisplay = deviceData.allIds.length > 1
                    ? `${deviceData.allIds.length} sessions`
                    : `ID: ${deviceData.primaryId}`;

                deviceItem.innerHTML = `
                    <div class="device-name">
                        <span class="status-indicator ${isOnline ? 'status-online' : 'status-offline'}"></span>
                        ${deviceData.name || deviceData.primaryId}
                    </div>
                    <div class="device-info">
                        <span>${idDisplay}</span>
                        <span class="last-seen">
                            ${isOnline ? 'Online' : `Last seen: ${Math.floor(timeSinceLastSeen / 1000)}s ago`}
                        </span>
                    </div>
                `;

                deviceList.appendChild(deviceItem);
            });
        }

        function initChart() {
            const ctx = document.getElementById('deviceChart').getContext('2d');
            deviceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Connected Devices',
                        data: [],
                        borderColor: '#00ff88',
                        backgroundColor: 'rgba(0, 255, 136, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#fff'
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#888',
                                maxTicksLimit: 12
                            },
                            grid: {
                                color: '#333'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#888',
                                stepSize: 1
                            },
                            grid: {
                                color: '#333'
                            }
                        }
                    }
                }
            });
        }

        function updateChart() {
            const now = new Date();
            const currentDeviceCount = connectedDevices.size;

            // Add current data point
            chartData.push({
                time: now.getTime(),
                count: currentDeviceCount,
                label: now.toLocaleTimeString('hu-HU', { hour: '2-digit', minute: '2-digit' })
            });

            // Remove data older than 24 hours
            const twentyFourHoursAgo = now.getTime() - (24 * 60 * 60 * 1000);
            while (chartData.length > 0 && chartData[0].time < twentyFourHoursAgo) {
                chartData.shift();
            }

            // Update chart data
            if (deviceChart) {
                deviceChart.data.labels = chartData.map(point => point.label);
                deviceChart.data.datasets[0].data = chartData.map(point => point.count);
                deviceChart.update('none'); // No animation for performance
            }
        }

        function resetChart() {
            // Clear all chart data
            chartData.length = 0;

            // Update chart to show empty state
            if (deviceChart) {
                deviceChart.data.labels = [];
                deviceChart.data.datasets[0].data = [];
                deviceChart.update();
            }

            console.log('üìä Chart reset - data cleared');

            // Add current data point to restart tracking
            updateChart();
        }

        function processMessage(topic, message) {
            console.log(`üì® ${topic}: ${message}`);

            const parts = topic.split('/');
            if (parts.length < 3 || parts[0] !== 'pierre') return;

            let deviceId = null;
            let deviceName = null;
            const now = Date.now();

            // Handle different topic structures
            if (parts[1] === 'status' && parts.length >= 4) {
                // pierre/status/DEVICE_ID/online or pierre/status/DEVICE_ID/offline
                deviceId = parts[2];
                const status = parts[3];

                if (status === 'online') {
                    try {
                        // Parse JSON message from StatisticsManager
                        const data = JSON.parse(message);
                        deviceName = data.device_name || deviceId;
                    } catch (e) {
                        deviceName = message || deviceId;
                    }
                } else if (status === 'offline') {
                    // Device going offline, keep in list but mark as offline
                    if (connectedDevices.has(deviceId)) {
                        const existing = connectedDevices.get(deviceId);
                        connectedDevices.set(deviceId, {
                            ...existing,
                            lastSeen: now - 60000 // Mark as 1 minute old to show offline
                        });
                    }
                    updateDeviceList();
                    updateChart();
                    return;
                }
            } else if (parts[1] === 'serial' && parts.length >= 5) {
                // pierre/serial/DEVICE_ID/SESSION_ID/info
                deviceId = parts[2];
                const messageType = parts[4];

                if (messageType === 'info' && message.includes('|')) {
                    // Info topic format: "deviceName|batteryPct"
                    deviceName = message.split('|')[0];
                } else {
                    // Keep existing name if we have it
                    if (connectedDevices.has(deviceId)) {
                        deviceName = connectedDevices.get(deviceId).name;
                    } else {
                        deviceName = deviceId;
                    }
                }
            } else if (parts[1] === 'stats' && parts.length >= 4) {
                // pierre/stats/DEVICE_ID/operation_type
                deviceId = parts[2];

                try {
                    // Try to parse JSON stats message
                    const data = JSON.parse(message);
                    deviceName = data.device_name || deviceId;
                } catch (e) {
                    // Keep existing name or use deviceId
                    if (connectedDevices.has(deviceId)) {
                        deviceName = connectedDevices.get(deviceId).name;
                    } else {
                        deviceName = deviceId;
                    }
                }
            }

            // Update device data if we have a deviceId
            if (deviceId) {
                connectedDevices.set(deviceId, {
                    name: deviceName || deviceId,
                    lastSeen: now,
                    topic: topic
                });

                updateDeviceList();
                updateChart();
            }
        }

        function cleanupOfflineDevices() {
            const now = Date.now();
            const timeout = 60000; // 1 minute timeout

            for (const [deviceId, deviceData] of connectedDevices.entries()) {
                if (now - deviceData.lastSeen > timeout) {
                    connectedDevices.delete(deviceId);
                }
            }

            updateDeviceList();
            updateChart();
        }

        function connectMQTT() {
            console.log('üîå Connecting to HiveMQ Cloud...');

            try {
                client = mqtt.connect(MQTT_HOST, {
                    username: USERNAME,
                    password: PASSWORD,
                    clientId: `pierre-monitor-${Math.random().toString(16).substr(2, 8)}`,
                    keepalive: 30,
                    clean: true
                });

                client.on('connect', () => {
                    console.log('‚úÖ Connected to HiveMQ Cloud');
                    updateConnectionStatus(true);

                    // Subscribe to all pierre topics
                    client.subscribe('pierre/#', (err) => {
                        if (err) {
                            console.error('‚ùå Subscription error:', err);
                        } else {
                            console.log('üì° Subscribed to pierre/#');
                        }
                    });
                });

                client.on('message', (topic, payload) => {
                    const message = payload.toString();
                    processMessage(topic, message);
                });

                client.on('error', (error) => {
                    console.error('‚ùå MQTT Error:', error);
                    updateConnectionStatus(false);
                });

                client.on('offline', () => {
                    console.log('üì° MQTT Offline');
                    updateConnectionStatus(false);
                });

                client.on('close', () => {
                    console.log('üîå MQTT Connection Closed');
                    updateConnectionStatus(false);
                });

            } catch (error) {
                console.error('‚ùå MQTT Connection Error:', error);
                updateConnectionStatus(false);
            }
        }

        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize chart
            initChart();

            // Add initial data point
            updateChart();

            // Setup reset button
            document.getElementById('resetChart').addEventListener('click', resetChart);

            // Start monitoring
            connectMQTT();

            // Clean up offline devices every 30 seconds
            setInterval(cleanupOfflineDevices, 30000);

            // Update device list every 5 seconds to refresh "last seen" times
            setInterval(updateDeviceList, 5000);

            // Update chart every minute
            setInterval(updateChart, 60000);
        });
    </script>
</body>
</html>